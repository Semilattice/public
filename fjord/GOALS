The following are goals and the approaches to achieve them.

 - Make functional programming easy. Functional programming means programming
   with functions, which are total, deterministic, and pure. Other languages
   to learn from include Haskell, Idris and PureScript. A strong type system
   featuring HKTs is an absolute must for functional programming to be a
   pleasant experience.

 - Compile programs very quickly. This should be achievable by splitting the
   separate compilation steps into separate programs, which can be invoked by
   a build system that caches intermediate artifacts. Artifacts include not
   only object files, but also token streams, ASTs, and desugared programs.
   This increases the potential for caching and parallelism. For example, all
   top-level functions can be compiled in parallel; and if you just change one
   function you do not have to recompile all the other functions that are in
   the same source file.

 - The programmer should have the freedom to organize their code however they
   wish. This can be compared with literate programming (like in WEB, not
   like in Haskell). Compilation units, namespaces, and source files are all
   separate concepts and they are not conflated in any way. For example, you
   can define two functions in one source file, which are compiled
   separately. The separation of parsing and semantic analysis into separate
   programs as mentioned before should help achieve this. Do not force an
   ad-hoc build system upon the user; let them use whatever language-agnostic
   build system they want (Bazel, GNU Make, Snowflake, etc).

 - Have good type and runtime systems for programs that run for a long time and
   use dozens of gigabytes of memory. I/O actions should be indexed by their
   error types, as in the ZIO Scala library. It should be possible to create
   disjoint heaps a la Erlang, with pluggable GC strategies. Do not feature
   unchecked exceptions and asynchronous exceptions at all, and clearly mark
   non-total "functions" by naming them in all caps.

 - Allow the programmer to gracefully handle out of memory conditions. Do not
   overcommit a terabyte of memory. Because of the no exceptions policy this
   may be slightly tricky; perhaps require the programmer to provide an OOM
   handler (and give a linker error otherwise). One such handler could exist
   for every heap.

 - Think extremely hard about non-trivial libraries. Model APIs closely after
   their domains, instead of thinking up potential use cases and forcing
   everything into them. Provide a low-level API that is always semantically
   correct and close to the domain, and build higher-level convenience
   functions on top of them rather than baking them in. Typical examples
   include date/time libraries, locale libraries, and I/O streams.

The following are not goals. They are included because counterexamples are a
good way to undo confusion.

 - Get as many people as possible to use Fjord. Just make Fjord a very good
   programming language, and leave it up to people whether they want to use it
   or not. Do not sacrifice correctness, robustness, and explicitness for
   convenience or fancy tickling.

 - Be a test bench for language features and type theory. There are already
   good languages that do this, such as Haskell and Idris. Learn from their
   successes and mistakes, instead of taking the risky road and implementing
   brand new features.

 - Be a good language for all domains. PureScript, Rust, and your favorite
   obscure DSL deserve some love too! Fjord is mainly a programming language
   for long-running server-side applications.
